# Общее

В этом домашнем задании вам предлагается познакомиться с языком программирования Rust и многопоточностью с точки зрения прикладного программиста.
Здесь всего одна задача, которая оценивается в 5 баллов, из них 50% вы получаете за корректность и 50% за стиль.
К сожалению, мы не являемся экспертами в Rust, поэтому стиль будет проверяться относительно поверхностно.

# Задание

В папке `sudoku` лежит Cargo-проект, представляющий собой программу, перебирающую решения головоломки ["Судоку"](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B4%D0%BE%D0%BA%D1%83).
Вам нужно реализовать многопоточную версию этой программы на основе выданной, используя пул потоков из крейта `threadpool` и каналы.

## Подробнее

Вам потребуются Rust и Cargo версии 1.33 (вероятно, более новая тоже подойдёт).
Если вы пользуетесь Linux, её может не оказаться в репозиториях вашего дистрибутива, тогда
рекомендуется поставить rustup для конкретного пользователя и воспользоваться им для установки нужной версии.

Для выполнения задания вам необходимо выполнить инструкцию ниже:

1. Прочитайте код в файлах `sudoku/field.rs` и `sudoku/main.rs` (лучше в таком порядке) и убедитесь, что вы понимаете, какие конструкции мы используем и общую логику решения.
   Вы также можете сгенирировать HTML-версию комментариев при помощи команды `cargo doc --document-private-items`
   (она сохранит набор HTML-файлов в папке `target/doc`).
2. Создайте в функции `find_solution_parallel()` канал функцией `std::sync::mpsc::channel()` и вместо того,
   чтобы напрямую использовать результат `find_solution()`, сначала запишите его
   в канал, а потом сразу прочитайте `Option<Field>` из канала.
   Это нужно, чтобы потом можно было запустить `find_solution()` в отдельном потоке и
   всё равно получить результат в `find_solution_parallel()`.
   Изменять `find_solution()` не требуется.
   Сейчас поведение программы измениться не должно.
3. Добавьте в `Cargo.toml` зависимость [`threadpool`](https://docs.rs/threadpool/1.7.1/threadpool/).
   После этого в `main.rs` и остальных файлов сразу можно использовать `threadpool::` (команда `extern crate` с выпуском Rust 2018 неактуальна).
4. Создайте в `find_solution_parallel()` пул из 8 рабочих потоков.
5. Запустите функцию `find_solution()` и передачу результата в канал как одну задачу в пуле потоков.
   Убедитесь, что поведение и скорость работы программы не изменились.
   Убедитесь, что загружается только одно ядро процессора.
6. Начиная с этого шага придётся активно думать :)
   Когда мы распараллелим код, у нас в канале может оказаться несколько сообщений.
   Нас интересует не первое из них, а первое вида `Some()`.
   Обобщите код чтения сообщения из канала:
   1. Преобразуйте читающий конец канала в итератор при помощи `Receiver::into_iter()` (осторожно: не вызовите его на результате `recv()`, это будет не то).
      Итератор остановится, когда все пишущие концы канала будут удалены (дропнуты):
      перемещены в замыкание, которое уже выполнилось, или при помощи явного `std::mem::drop()`.
   2. На полученном итераторе вызовите метод `Iterator::find_map()` с нужными аргументами.
      Он позволяет найти в итераторе первое значения вида `Some()`.
      Если же нижележащий итератор остановится (потому что все пишущие концы канала удалены), то
      `find_map()` вернёт `None`.
   3. Допишите код, чтобы поведение программы не изменилось.
7. Вместо отправки одной задачи в пул потоков переберите значения одной из клеток поля при помощи `try_extend_field()` и
   отправьте в пул потоков 9 задач (по одной на каждое значение клетки).
   * Каждая задача — это запуск функции `find_solution()` на частично заполненном поле (плюс, возможно, ещё пара простых команд).
   * Обратите внимание, что для корректной работы решения _все_ записывающие концы канала должны быть закрыты, когда задачи заканчивают работу.
   * Обратите внимание, что при нахождении ответа функция `find_solution_parallel()` завершает свою работу и закрывает канал.
     Это может вызывать паники при отправке сообщений в канал из других потоков, эти паники стоит обработать.
8. Вынесите код отправки нескольких задач в отдельную функцию `spawn_tasks()`.
   Параметры функции остаются на ваше усмотрение, однако ей как минимум потребуется:
   * Пул потоков
   * Конец канала, в который необходимо записать ответ
   * Исходное поле
9. Убедитесь, что поведение программы не изменилось.
   Скорость работы в этот момент могла незначительно увеличиться.
   Убедитесь, что задачи действительно работают параллельно: 
   либо выведите на экран сообщение в начале и в конце каждой задачи,
   либо воспользуйтесь методами `ThreadPool::active_count()` и `ThreadPool::queued_count()`.
   Убедитесь, что хотя бы в начале программы загружается больше одного ядра процессора.
10. Создавать 9 задач на 8 потоков — не самая хорошая идея, потому что
   если одна задача выполнится сильно быстрее другой (например, из-за противоречия), потоки начнут простаивать.
   Поэтому перед созданием задачи вам требуется перебрать значения не одной клетки поля,
   а `SPAWN_DEPTH` клеток поля.
   Добавьте константу `SPAWN_DEPTH: i32 = 1` и измените `spawn_tasks()` так, чтобы она
   рекурсивно перебирала значения первых `SPAWN_DEPTH` клеток и запускала отдельную задачу
   только после этого.
11. Убедитесь, что поведение и скорость работы программы не изменились.
12. Измените `SPAWN_DEPTH` с 1 на 2.
    Убедитесь, что поведение программы не изменилось,
    а скорость выросла и загрузка процессора стала больше.

## Советы
Полезные команды Cargo (выполнять в папке `sudoku`):
* `cargo build` — полная сборка программы без оптимизаций (результат появляется в папке `target/debug`)
* `cargo build --release` — полная сборка программы с включёнными оптимизациями  (результат появляется в папке `target/release`)
* `cargo check` — проверка корректности программы без создания выполняемого файла.
      Отличается от `cargo build` тем, что работает сильно быстрее.
* `cargo test` — запустить все автоматические тесты
* `cargo clean` — удаление временных файлов
* `cargo fmt` — автоформатирование всех файлов при помощи rustfmt (требует его установки; например, через `rustup component add rustfmt`)

Вы можете проверять корректность решения, запустив его на одном из файлов из папки `tests/`.
На компьютере `@yeputons` предоставленная версия на всех тестах, кроме `04-hard.in`, работает меньше секунды,
если собрать с оптимизациями (`build --release`).
На `04-hard.in` она работает порядка 50 секунд (этот тест взят [из английской Википедии](https://en.wikipedia.org/wiki/Sudoku_solving_algorithms)).

Если у вас не компилируется, работает медленно или вообще происходит что-то непонятное — не стесняйтесь спрашивать нас, что делать.
Некоторые ошибки может быть трудно отловить самостоятельно в первый раз.

Скорее всего, большинство ошибок у вас будет не из-за многопоточности, а из-за логики работы программы.
Отлаживайте программу, как будто она однопоточная (разве что не ориентируйтесь на порядок
отладочного вывода между потоками, там гонка).
Если совсем затык — можете вместо отправки задачи в пул потоков выполнить её прямо "на месте" (inline),
тогда программа станет строго однопоточной и отладочный вывод станет детерминированным.

Чтобы проверить нагрузку на процессор, вы можете использовать:
* Под Windows: диспетчер задач. Загрузка в 100% означает полное использование _всех_ ядер процессора.
  Чтобы узнать количество логических ядер процессора, посмотрите вкладку "Performance".
  Например, если у процессора 2 физических ядра и 4 логических (с учётом hyper-threading),
  то полная загрузка одного ядра будет обозначаться как 25%.
* Под Linux: консольную команду `htop`. Загрузка в 100% означает полное исользование _одного_ ядра.
  Чтобы узнать количество логических ядер процессора, запустите команду `cat /proc/cpuinfo`.

Обратите внимание, что предупреждения выдаются только при перекомпиляции файла, а не при каждом `cargo build`.
Если он уже один раз скомпилирован и не менялся, то для получения предупреждений про файл вам нужно сделать `cargo clean`.
Если в вашем `main.rs` есть строчка `#![deny(warnings)]` (в последней версии задания она появилась),
то это не влияет, потому что вы не сможете скомпилировать файл с предупреждениями.

# Тесты

В представленной реализации уже имеется несколько автоматических тестов.
Вам не требуется добавлять свои собственные, однако требуется не сломать имеющиеся.

# Требования к корректности решения

Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Строгость предупреждений и диагностик в `cargo.toml` не понижена
* Отсутствуют атрибуты `#![rustfmt::skip]` и подобное заглушение автопроверки
* Если `rustfmt.toml` изменён, то это происходит в самом первом коммите одновременно с автоматическим переформатированием предоставленного кода
* Все проверки на Travis проходят:
  * `cargo build` должен собирать исполняемый файл без ошибок и предупреждений
  * `cargo test` отрабатывает без ошибок
  * Файлы не изменяются при форматировании [rustfmt](https://github.com/rust-lang/rustfmt)
* Файл `field.rs` не изменён
* Функции `try_extend_field`, `find_solution`, `main` не изменены
* Все имеющиеся тесты оставлены без изменений; добавлять новые можно
* Не используется `unsafe`
* При запуске решения на любых корректных тестах (в том числе нерешаемых) не должно происходить паник
* Решение должно хоть в каких-то случаях работать существенно быстрее не многопоточного и загружать все доступные ядра процессора хотя бы на какое-то время.
  Например, официальное решение на компьютере преподавателя на тесте `04-hard.in` ускоряется примерно в два с половиной раза (с ~50 секунд до ~20).
  Если вам не удаётся выполнить это условие — пишите, обсудим, поможем.

# Формат сдачи
Если возникают **любые** непонятки с форматом сдачи (даже простые и мелкие) - пишите преподавателю!
Мы не хотим, чтобы вы не сдали просто потому что кто-то не очень хорошо рассказал Git или дал мало практики :)

* Для сдачи домашнего задания откройте pull request в ветку `master` нашего репозитория
* Pull request должен удовлетворять следующим требованиям, иначе он не будет проверен:
  * Название: `Task08, GroupXX, Фамилия Имя`
    * Например, `Task08, Group09, Суворов Егор`
    * Не допускаются сокращения, перестановка слов, отсутствие запятой, пробелов или написание имени транслитом
  * Отсутствуют merge conflicts
  * В сумме за все коммиты (вкладка "Files Changed") отсутствуют временные файлы вроде `.*.swp`, настройки среды вроде `.idea` и прочий мусор.
    Разрешается добавлять новые файлы только если это требуется заданием.
    * Если вам хочется добавить `.gitignore`, добавьте его [конкретно на вашем компьютере](https://help.github.com/en/articles/ignoring-files#create-a-global-gitignore)
      при помощи `git config --global core.excludesfile` или [конкретно в вашем клоне](https://help.github.com/en/articles/ignoring-files#explicit-repository-excludes)
      через файл `.git/info/exclude`
  * Ни в одном из коммитов не смешаны изменения, относящиеся к разным задачам
  * В описании pull request упомянут ваш преподаватель:
    для `18.Б09-пу` — `@yeputons`, для `18.Б10-пу` — `@edgarzhavoronkov`
* В каждый момент времени может быть открыто не более одного pull request
* Вопросы следует задавать либо по почте, либо открыв Issue в репозитории в произвольной форме и с названием содержащим вопрос, начинающимся с `Task 08:`
* Для сдачи задания отправлять письмо не требуется, достаточно открытия Pull Request по установленной форме
* Для проверки преподаватель назначает себя reviewer и отправляет вам review прямо на GitHub
  * Approved означает полное засчитывание упомянутых в pull request задач по корректности и стилю
  * Changes requested означает, что что-то надо доделать (при этом могут быть уже зачтены какие-то задачи или может быть зачтена корректность)
* Если вам захотелось исправить решение после прохождения review, вам требуется:
  * Добавить один или более коммитов с исправлениями
    * При этом запрещается переписывать историю, которую уже видел преподаватель на момент проверки, если только это не было обговорено в явном виде
    * В процессе исправлений вы можете переписывать историю добавленных коммитов (которые преподаватель ещё не видел)
  * Если вы хотите исправить стиль, то на каждое замечание по стилю в review требуется одно из двух:
    1. Оставить комментарий с пояснением, почему вы с замечанием не согласны или не исправили
    1. Исправить и ничего не комментировать: преподаватель либо нажмёт кнопку "Resolve conversation" и скроет комментарий, либо молча оставит его актуальным
  * Оставить в pull request комментарий `исправлено` с упоминанием вашего преподавателя.
    Например: `@yeputons, исправлено`.
    До появления комментария считается, что вы в процессе исправления, и pull request не проверяется
  * Если вы хотите оставить больше одного комментария (например, кроме `исправлено` хотите ответить ещё на что-то),
    оставляйте комментарии по коду на вкладке "Files changed" при помощи кнопки "Start review",
    а комментарий к pull request в целом оставляйте кнопкой "Review changes - Comment".
    Другими словами, отвечайте, как будто [вы сами делаете review](https://help.github.com/en/articles/reviewing-proposed-changes-in-a-pull-request).
    Таким образом мы будем получать на почту только одно письмо на ваш ответ, а не несколько.
* Если вам захотелось исправить решение до прохождения review, но после открытия pull request или после комментария `исправлено`,
  требования такие же: добавляете новые коммиты, старые не переписываете, в конце оставляете ещё один комментарий
* После вердикта `Approved` или прохождения жёсткого дедлайна pull request закрывается.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|12.04.2019|12.04.2019||
|Мягкий дедлайн|21.04.2019 22:59|21.04.2019 22:59|5|
|Жёсткий дедлайн|28.04.2019 22:59|28.04.2019 22:59|2.5|
